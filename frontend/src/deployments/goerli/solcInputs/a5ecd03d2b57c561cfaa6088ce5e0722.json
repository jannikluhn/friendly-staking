{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/gnosis/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes memory pubkey,\n        bytes memory withdrawal_credentials,\n        bytes memory signature,\n        bytes32 deposit_data_root,\n        uint256 stake_amount\n    ) external;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "src/gnosis/interfaces/IERC677.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC677 is IERC20 {\n    function transferAndCall(address to, uint256 amount, bytes calldata data) external;\n}\n"
    },
    "src/gnosis/interfaces/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\ninterface IERC677Receiver {\n    function onTokenTransfer(address from, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "src/gnosis/interfaces/IUnwrapper.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\ninterface IUnwrapper {\n    /**\n     * @dev Swaps some of the wrapped tokens to the whitelisted token.\n     * Wrapped tokens will be burned.\n     * @param _token Address of the whitelisted token contract.\n     * @param _amount Amount of tokens to swap.\n     * @return Amount of returned tokens.\n     */\n    function unwrap(address _token, uint256 _amount) external returns (uint256);\n}\n"
    },
    "src/gnosis/interfaces/IWithdrawalContract.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\ninterface IWithdrawalContract {\n    /**\n     * @dev Function to be used only in the system transaction.\n     * Call to this function will revert only in three cases:\n     *     - the caller is not `SYSTEM_WITHDRAWAL_EXECUTOR` or `_admin()`;\n     *     - the length of `_amounts` array is not equal to the length of `_addresses` array;\n     *     - it is a reentrant access to failed withdrawals processing;\n     *     - the call ran out of gas.\n     * Call to this function doesn't transmit flow control to any untrusted contract and uses a constant gas limit for each withdrawal,\n     * so using constant gas limit and constant number of withdrawals (including failed withdrawals) for calls of this function is ok.\n     * @param _maxNumberOfFailedWithdrawalsToProcess Maximum number of failed withdrawals to be processed.\n     * @param _amounts Array of amounts to be withdrawn.\n     * @param _addresses Array of addresses that should receive the corresponding amount of tokens.\n     */\n    function executeSystemWithdrawals(\n        uint256 _maxNumberOfFailedWithdrawalsToProcess,\n        uint64[] calldata _amounts,\n        address[] calldata _addresses\n    ) external;\n\n    /// @notice Executed withdrawal event.\n    event WithdrawalExecuted(uint256 _amount, address indexed _address);\n\n    /// @notice Failed withdrawal event.\n    event WithdrawalFailed(uint256 indexed _failedWithdrawalId, uint256 _amount, address indexed _address);\n\n    /**\n     * @dev Function to be used to process failed withdrawals.\n     * Call to this function will revert only if it ran out of gas or it is a reentrant access to failed withdrawals processing.\n     * Call to this function doesn't transmit flow control to any untrusted contract and uses a constant gas limit for each withdrawal,\n     * so using constant gas limit and constant max number of withdrawals for calls of this function is ok.\n     * @param _maxNumberOfFailedWithdrawalsToProcess Maximum number of failed withdrawals to be processed.\n     */\n    function processFailedWithdrawalsFromPointer(uint256 _maxNumberOfFailedWithdrawalsToProcess) external;\n\n    /**\n     * @dev Function to be used to process a failed withdrawal (possibly partially).\n     * @param _failedWithdrawalId Id of a failed withdrawal.\n     * @param _amountToProceed Amount of token to withdraw (for the case it is impossible to withdraw the full amount)\n     * (available only for the receiver, will be ignored if other account tries to process the withdrawal).\n     */\n    function processFailedWithdrawal(uint256 _failedWithdrawalId, uint256 _amountToProceed) external;\n\n    /// @notice Processed (possibly partially) failed withdrawal event.\n    event FailedWithdrawalProcessed(\n        uint256 indexed _failedWithdrawalId,\n        uint256 _processedAmount,\n        address indexed _address\n    );\n}\n"
    },
    "src/gnosis/SBCDepositContract.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./interfaces/IDepositContract.sol\";\nimport \"./interfaces/IERC677Receiver.sol\";\nimport \"./interfaces/IUnwrapper.sol\";\nimport \"./interfaces/IWithdrawalContract.sol\";\nimport \"./utils/PausableEIP1967Admin.sol\";\nimport \"./utils/Claimable.sol\";\n\n/**\n * @title SBCDepositContract\n * @dev Implementation of the ERC20 ETH2.0 deposit contract.\n * For the original implementation, see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\n */\ncontract SBCDepositContract is\n    IDepositContract,\n    IERC165,\n    IERC677Receiver,\n    PausableEIP1967Admin,\n    Claimable,\n    IWithdrawalContract\n{\n    using SafeERC20 for IERC20;\n\n    uint256 private constant DEPOSIT_CONTRACT_TREE_DEPTH = 32;\n    // NOTE: this also ensures `deposit_count` will fit into 64-bits\n    uint256 private constant MAX_DEPOSIT_COUNT = 2 ** DEPOSIT_CONTRACT_TREE_DEPTH - 1;\n\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] private zero_hashes;\n\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] private branch;\n    uint256 private deposit_count;\n\n    mapping(bytes => bytes32) public validator_withdrawal_credentials;\n\n    IERC20 public immutable stake_token;\n\n    constructor(address _token) {\n        stake_token = IERC20(_token);\n    }\n\n    function get_deposit_root() external view override returns (bytes32) {\n    }\n\n    function get_deposit_count() external view override returns (bytes memory) {\n    }\n\n    function deposit(\n        bytes memory pubkey,\n        bytes memory withdrawal_credentials,\n        bytes memory signature,\n        bytes32 deposit_data_root,\n        uint256 stake_amount\n    ) external override whenNotPaused {\n        stake_token.transferFrom(msg.sender, address(this), stake_amount);\n        _deposit(pubkey, withdrawal_credentials, signature, deposit_data_root, stake_amount);\n    }\n\n    function batchDeposit(\n        bytes calldata pubkeys,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signatures,\n        bytes32[] calldata deposit_data_roots\n    ) external whenNotPaused {\n    }\n\n    function onTokenTransfer(\n        address,\n        uint256 stake_amount,\n        bytes calldata data\n    ) external override whenNotPaused returns (bool) {\n        require(msg.sender == address(stake_token), \"DepositContract: not a deposit token\");\n        require(data.length % 176 == 32, \"DepositContract: incorrect deposit data length\");\n        uint256 count = data.length / 176;\n        require(count > 0, \"BatchDeposit: You should deposit at least one validator\");\n        uint256 stake_amount_per_deposit = stake_amount;\n        if (count > 1) {\n            require(count <= 128, \"BatchDeposit: You can deposit max 128 validators at a time\");\n            require(stake_amount == 1 ether * count, \"BatchDeposit: batch deposits require 1 GNO deposit amount\");\n            stake_amount_per_deposit = 1 ether;\n        }\n\n        bytes memory withdrawal_credentials = data[0:32];\n        for (uint256 p = 32; p < data.length; p += 176) {\n            bytes memory pubkey = data[p:p + 48];\n            bytes memory signature = data[p + 48:p + 144];\n            bytes32 deposit_data_root = bytes32(data[p + 144:p + 176]);\n            _deposit(pubkey, withdrawal_credentials, signature, deposit_data_root, stake_amount_per_deposit);\n        }\n        return true;\n    }\n\n    function _deposit(\n        bytes memory pubkey,\n        bytes memory withdrawal_credentials,\n        bytes memory signature,\n        bytes32 deposit_data_root,\n        uint256 stake_amount\n    ) internal {\n    }\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IDepositContract).interfaceId ||\n            interfaceId == type(IERC677Receiver).interfaceId;\n    }\n\n    /**\n     * @dev Allows to transfer any locked token from this contract.\n     * Only admin can call this method.\n     * Deposit-related tokens cannot be claimed.\n     * @param _token address of the token, if it is not provided (0x00..00), native coins will be transferred.\n     * @param _to address that will receive the locked tokens from this contract.\n     */\n    function claimTokens(address _token, address _to) external onlyAdmin {\n    }\n\n    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {\n        ret = new bytes(8);\n        bytes8 bytesValue = bytes8(value);\n        // Byteswapping during copying to bytes.\n        ret[0] = bytesValue[7];\n        ret[1] = bytesValue[6];\n        ret[2] = bytesValue[5];\n        ret[3] = bytesValue[4];\n        ret[4] = bytesValue[3];\n        ret[5] = bytesValue[2];\n        ret[6] = bytesValue[1];\n        ret[7] = bytesValue[0];\n    }\n\n    /*** Withdrawal part ***/\n\n    address private constant SYSTEM_WITHDRAWAL_EXECUTOR = 0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE;\n\n    uint256 private constant DEFAULT_GAS_PER_WITHDRAWAL = 300000;\n\n    /**\n     * @dev Function to be used to process a withdrawal.\n     * Actually it is an internal function, only this contract can call it.\n     * This is done in order to roll back all changes in case of revert.\n     * @param _amount Amount to be withdrawn.\n     * @param _receiver Receiver of the withdrawal.\n     */\n    function processWithdrawalInternal(uint256 _amount, address _receiver) external {\n    }\n\n    /**\n     * @dev Internal function to be used to process a withdrawal.\n     * Uses processWithdrawalInternal under the hood.\n     * Call to this function will revert only if it ran out of gas.\n     * @param _amount Amount to be withdrawn.\n     * @param _receiver Receiver of the withdrawal.\n     * @return success An indicator of whether the withdrawal was successful or not.\n     */\n    function _processWithdrawal(uint256 _amount, address _receiver, uint256 gasLimit) internal returns (bool success) {\n    }\n\n    struct FailedWithdrawalRecord {\n        uint256 amount;\n        address receiver;\n        uint64 withdrawalIndex;\n    }\n    mapping(uint256 => FailedWithdrawalRecord) public failedWithdrawals;\n    mapping(uint64 => uint256) public failedWithdrawalIndexByWithdrawalIndex;\n    uint256 public numberOfFailedWithdrawals;\n    uint64 public nextWithdrawalIndex;\n\n    /**\n     * @dev Function to be used to process a failed withdrawal (possibly partially).\n     * @param _failedWithdrawalId Id of a failed withdrawal.\n     * @param _amountToProceed Amount of token to withdraw (for the case it is impossible to withdraw the full amount)\n     * (available only for the receiver, will be ignored if other account tries to process the withdrawal).\n     */\n    function processFailedWithdrawal(uint256 _failedWithdrawalId, uint256 _amountToProceed) external whenNotPaused {\n    }\n\n    uint256 public failedWithdrawalsPointer;\n\n    /**\n     * @dev Function to be used to process failed withdrawals.\n     * Call to this function will revert only if it ran out of gas or it is a reentrant access to failed withdrawals processing.\n     * Call to this function doesn't transmit flow control to any untrusted contract and uses a constant gas limit for each withdrawal,\n     * so using constant gas limit and constant max number of withdrawals for calls of this function is ok.\n     * @param _maxNumberOfFailedWithdrawalsToProcess Maximum number of failed withdrawals to be processed.\n     */\n    function processFailedWithdrawalsFromPointer(uint256 _maxNumberOfFailedWithdrawalsToProcess) public {\n    }\n\n    /**\n     * @dev Function to be used only in the system transaction.\n     * Call to this function will revert only in three cases:\n     *     - the caller is not `SYSTEM_WITHDRAWAL_EXECUTOR` or `_admin()`;\n     *     - the length of `_amounts` array is not equal to the length of `_addresses` array;\n     *     - it is a reentrant access to failed withdrawals processing;\n     *     - the call ran out of gas.\n     * Call to this function doesn't transmit flow control to any untrusted contract and uses a constant gas limit for each withdrawal,\n     * so using constant gas limit and constant number of withdrawals (including failed withdrawals) for calls of this function is ok.\n     * @param _maxNumberOfFailedWithdrawalsToProcess Maximum number of failed withdrawals to be processed.\n     * @param _amounts Array of amounts to be withdrawn.\n     * @param _addresses Array of addresses that should receive the corresponding amount of tokens.\n     */\n    function executeSystemWithdrawals(\n        uint256 _maxNumberOfFailedWithdrawalsToProcess,\n        uint64[] calldata _amounts,\n        address[] calldata _addresses\n    ) external {\n    }\n\n    /**\n     * @dev Check if a block's withdrawal has been fully processed or not\n     * @param _withdrawalIndex EIP-4895 withdrawal.index property\n     */\n    function isWithdrawalProcessed(uint64 _withdrawalIndex) external view returns (bool) {\n    }\n\n    /**\n     * @dev Allows to unwrap the mGNO in this contract to GNO\n     * Only admin can call this method.\n     * @param _unwrapper address of the mGNO token unwrapper\n     */\n    function unwrapTokens(IUnwrapper _unwrapper, IERC20 _token) external onlyAdmin {\n    }\n}\n"
    },
    "src/gnosis/SBCDepositContractProxy.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"./utils/EIP1967Proxy.sol\";\nimport \"./SBCDepositContract.sol\";\n\n/**\n * @title SBCDepositContractProxy\n * @dev Upgradeable version of the underlying SBCDepositContract.\n */\ncontract SBCDepositContractProxy is EIP1967Proxy {\n    bool private paused;\n\n    uint256 private constant DEPOSIT_CONTRACT_TREE_DEPTH = 32;\n    // first slot from StakeDepositContract\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] private zero_hashes;\n\n    constructor(address _admin, address _token) {\n        _setAdmin(_admin);\n        _setImplementation(address(new SBCDepositContract(_token)));\n\n        // Compute hashes in empty sparse Merkle tree\n        for (uint256 height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH - 1; height++)\n            zero_hashes[height + 1] = sha256(abi.encodePacked(zero_hashes[height], zero_hashes[height]));\n    }\n}\n"
    },
    "src/gnosis/SBCToken.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"./utils/Claimable.sol\";\nimport \"./utils/PausableEIP1967Admin.sol\";\nimport \"./interfaces/IERC677.sol\";\nimport \"./interfaces/IERC677Receiver.sol\";\n\n/**\n * @title SBCToken\n * @dev Wrapped token used for depositing into SBC.\n */\ncontract SBCToken is IERC677, ERC20Pausable, PausableEIP1967Admin, Claimable {\n    address private _minter;\n\n    constructor() ERC20(\"\", \"\") {\n        // test tokens\n        _mint(msg.sender, 1280000000 ether);\n    }\n\n    /**\n     * @dev Initialization setter for the minter address.\n     * Only admin can call this method.\n     * @param minter address of the SBCWrapper contract.\n     */\n    function setMinter(address minter) external onlyAdmin {\n        require(_minter == address(0), \"SBCToken: minter already set\");\n        _minter = minter;\n    }\n\n    /**\n     * @dev Mints new tokens.\n     * Only configured minter is allowed to mint tokens, which should be a SBCWrapper contract.\n     * @param _to tokens receiver.\n     * @param _amount amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external {\n        require(_msgSender() == _minter, \"SBCToken: not a minter\");\n        _mint(_to, _amount);\n    }\n\n    /**\n     * @dev Burns tokens.\n     * Only configured minter is allowed to burn tokens, which should be a SBCWrapper contract.\n     * @param _from tokens owner.\n     * @param _amount amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount) external {\n        require(_msgSender() == _minter, \"SBCToken: not a minter\");\n        _burn(_from, _amount);\n    }\n\n    /**\n     * @dev Implements the ERC677 transferAndCall standard.\n     * Executes a regular transfer, but calls the receiver's function to handle them in the same transaction.\n     * @param _to tokens receiver.\n     * @param _amount amount of sent tokens.\n     * @param _data extra data to pass to the callback function.\n     */\n    function transferAndCall(address _to, uint256 _amount, bytes calldata _data) external override {\n        address sender = _msgSender();\n        _transfer(sender, _to, _amount);\n        require(IERC677Receiver(_to).onTokenTransfer(sender, _amount, _data), \"SBCToken: ERC677 callback failed\");\n    }\n\n    /**\n     * @dev Allows to transfer any locked token from this contract.\n     * Only admin can call this method.\n     * @param _token address of the token, if it is not provided (0x00..00), native coins will be transferred.\n     * @param _to address that will receive the locked tokens from this contract.\n     */\n    function claimTokens(address _token, address _to) external onlyAdmin {\n        _claimValues(_token, _to);\n    }\n}\n"
    },
    "src/gnosis/SBCTokenProxy.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"./utils/EIP1967Proxy.sol\";\nimport \"./SBCToken.sol\";\n\n/**\n * @title SBCTokenProxy\n * @dev Upgradeable version of the underlying SBCToken.\n */\ncontract SBCTokenProxy is EIP1967Proxy {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(address _admin, string memory name, string memory symbol) {\n        _setAdmin(_admin);\n        _setImplementation(address(new SBCToken()));\n        _name = name;\n        _symbol = symbol;\n    }\n}\n"
    },
    "src/gnosis/SBCWrapper.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IUnwrapper.sol\";\nimport \"./utils/PausableEIP1967Admin.sol\";\nimport \"./SBCToken.sol\";\nimport \"./SBCDepositContract.sol\";\n\n/**\n * @title SBCWrapper\n * @dev Wrapper engine contract for minting wrapped tokens that can be deposited into SBC.\n * Used for wrapping of STAKE and other possible ERC20 tokens.\n */\ncontract SBCWrapper is IERC677Receiver, PausableEIP1967Admin, Claimable, ReentrancyGuard, IUnwrapper {\n    using SafeERC20 for IERC20;\n\n    enum TokenStatus {\n        DISABLED,\n        ENABLED,\n        PAUSED\n    }\n\n    mapping(address => TokenStatus) public tokenStatus;\n    // if tokenRate[A] = X, then user will receive Y * X / 10**18 wrapped tokens for locking Y of A tokens.\n    mapping(address => uint256) public tokenRate;\n\n    SBCToken public immutable sbcToken;\n    SBCDepositContract public immutable sbcDepositContract;\n\n    event Swap(address indexed token, address indexed user, uint256 amount, uint256 received);\n    event SwapRateUpdated(address indexed token, uint256 rate);\n    event TokenSwapEnabled(address indexed token);\n    event TokenSwapPaused(address indexed token);\n    event Unwrap(address indexed token, address indexed user, uint256 amount, uint256 received);\n\n    constructor(SBCToken _sbcToken, SBCDepositContract _depositContract) {\n        sbcToken = _sbcToken;\n        sbcDepositContract = _depositContract;\n    }\n\n    /**\n     * @dev Enables swapping of new token into wrapped SBC token at a given rate.\n     * Only admin can call this method.\n     * @param _token address of the enabled or reenabled token contract.\n     * @param _rate exchange rate for the new pair, multiplied by 10**18.\n     */\n    function enableToken(address _token, uint256 _rate) external onlyAdmin {\n        require(_rate > 0, \"SBCWrapper: invalid rate\");\n\n        TokenStatus oldStatus = tokenStatus[_token];\n        tokenStatus[_token] = TokenStatus.ENABLED;\n        tokenRate[_token] = _rate;\n\n        if (oldStatus != TokenStatus.ENABLED) {\n            emit TokenSwapEnabled(_token);\n        }\n        emit SwapRateUpdated(_token, _rate);\n    }\n\n    /**\n     * @dev Temporary pauses swapping of some particular token, which can be reenaled later.\n     * Only admin can call this method.\n     * @param _token address of the paused token contract.\n     */\n    function pauseToken(address _token) external onlyAdmin {\n        require(tokenStatus[_token] == TokenStatus.ENABLED, \"SBCWrapper: token is not enabled\");\n\n        tokenStatus[_token] = TokenStatus.PAUSED;\n        emit TokenSwapPaused(_token);\n    }\n\n    /**\n     * @dev Swaps some of the whitelisted tokens for the newly created wrapped tokens.\n     * Tokens must be pre-approved before calling this function.\n     * @param _token address of the swapped token contract.\n     * @param _amount amount of tokens to swap.\n     * @param _permitData optional permit calldata to use for preliminary token approval.\n     * supports STAKE permit and EIP2612 standards.\n     */\n    function swap(address _token, uint256 _amount, bytes calldata _permitData) external nonReentrant whenNotPaused {\n        require(tokenStatus[_token] == TokenStatus.ENABLED, \"SBCWrapper: token is not enabled\");\n\n        if (_permitData.length > 4) {\n            // supported signatures:\n            // permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)\n            // permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\n            require(\n                bytes4(_permitData[0:4]) == bytes4(0x8fcbaf0c) || bytes4(_permitData[0:4]) == bytes4(0xd505accf),\n                \"SBCWrapper: invalid permit signature\"\n            );\n            (bool status, ) = _token.call(_permitData);\n            require(status, \"SBCWrapper: permit failed\");\n        }\n\n        address sender = _msgSender();\n\n        // We do not plan to support any deflationary or rebasing tokens in this contract\n        // so it is not required to check that ERC20 balance has indeed change.\n        // It is an admin responsibility to carefully check that enabled token correctly implements ERC20 standard.\n        IERC20(_token).safeTransferFrom(sender, address(this), _amount);\n\n        _swapTokens(sender, _token, _amount);\n    }\n\n    /**\n     * @dev ERC677 callback for swapping tokens in the simpler way during transferAndCall.\n     * @param from address of the received token contract.\n     * @param value amount of the received tokens.\n     * @param data should be empty for a simple token swap, otherwise will pass it further to the deposit contract.\n     */\n    function onTokenTransfer(\n        address from,\n        uint256 value,\n        bytes calldata data\n    ) external override nonReentrant whenNotPaused returns (bool) {\n        address token = _msgSender();\n        require(tokenStatus[token] == TokenStatus.ENABLED, \"SBCWrapper: token is not enabled\");\n\n        if (data.length == 0) {\n            _swapTokens(from, token, value);\n        } else {\n            uint256 swappedAmount = _swapTokens(address(this), token, value);\n            sbcToken.transferAndCall(address(sbcDepositContract), swappedAmount, data);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Allows to transfer any locked token from this contract.\n     * Only admin can call this method.\n     * While it is not allowed to claim previously enabled or paused tokens,\n     * the admin should still verify that the claimed token is a valid ERC20 token contract.\n     * @param _token address of the token, if it is not provided (0x00..00), native coins will be transferred.\n     * @param _to address that will receive the locked tokens on this contract.\n     */\n    function claimTokens(address _token, address _to) external onlyAdmin {\n        require(tokenStatus[_token] == TokenStatus.DISABLED, \"SBCWrapper: token already swappable\");\n\n        _claimValues(_token, _to);\n    }\n\n    function _swapTokens(address _receiver, address _token, uint256 _amount) internal returns (uint256) {\n        uint256 acquired = (_amount * tokenRate[_token]) / 1 ether;\n        require(acquired > 0, \"SBCWrapper: invalid amount\");\n\n        sbcToken.mint(_receiver, acquired);\n\n        emit Swap(_token, _receiver, _amount, acquired);\n\n        return acquired;\n    }\n\n    /**\n     * @dev Swaps some of the wrapped tokens to the whitelisted token.\n     * Wrapped tokens will be burned.\n     * @param _token Address of the whitelisted token contract.\n     * @param _amount Amount of tokens to swap.\n     * @return Amount of returned tokens.\n     */\n    function unwrap(address _token, uint256 _amount) external returns (uint256) {\n        require(tokenStatus[_token] == TokenStatus.ENABLED, \"SBCWrapper: token is not enabled\");\n\n        address sender = _msgSender();\n        sbcToken.burn(sender, _amount);\n\n        uint256 returned = (_amount * 1 ether) / tokenRate[_token];\n\n        IERC20(_token).safeTransfer(sender, returned);\n\n        emit Unwrap(_token, sender, _amount, returned);\n\n        return returned;\n    }\n}\n"
    },
    "src/gnosis/SBCWrapperProxy.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"./utils/EIP1967Proxy.sol\";\nimport \"./SBCWrapper.sol\";\n\n/**\n * @title SBCWrapperProxy\n * @dev Upgradeable version of the underlying SBCWrapper.\n */\ncontract SBCWrapperProxy is EIP1967Proxy {\n    constructor(address _admin, SBCToken _token, SBCDepositContract _depositContract) {\n        _setAdmin(_admin);\n        _setImplementation(address(new SBCWrapper(_token, _depositContract)));\n    }\n}\n"
    },
    "src/gnosis/test/SBCInit.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity ^0.8.9;\n\nimport \"../SBCDepositContractProxy.sol\";\nimport \"../SBCToken.sol\";\nimport \"../SBCTokenProxy.sol\";\nimport \"../SBCWrapper.sol\";\nimport \"../SBCWrapperProxy.sol\";\nimport \"./UnsafeToken.sol\";\n\ncontract SBCInit {\n    constructor(\n        address admin,\n        uint256 initialGNOStake,\n        address mGNOTokenProxyAddr,\n        address GNOTokenProxyAddr,\n        address depositProxyAddr,\n        address wrapperProxyAddr\n    ) {\n        SBCToken mGNOToken = SBCToken(mGNOTokenProxyAddr);\n        UnsafeToken GNOToken = UnsafeToken(GNOTokenProxyAddr);\n        SBCDepositContractProxy depositContractProxy = SBCDepositContractProxy(payable(depositProxyAddr));\n        SBCWrapper wrapper = SBCWrapper(wrapperProxyAddr);\n\n        // Enable wrapper\n        mGNOToken.setMinter(wrapperProxyAddr);\n        wrapper.enableToken(GNOTokenProxyAddr, 32);\n\n        // Mint initial stake\n        // With UnsafeToken the admin can already mint. Mint GNO directly to deposit contract\n        GNOToken.mint(depositProxyAddr, initialGNOStake);\n\n        // Prefund the admin account with some balance to test deposits\n        GNOToken.mint(admin, initialGNOStake);\n\n        // Change default admin on deploy (system sender) to actual admin\n        depositContractProxy.setAdmin(admin);\n        SBCTokenProxy(payable(mGNOTokenProxyAddr)).setAdmin(admin);\n        SBCTokenProxy(payable(GNOTokenProxyAddr)).setAdmin(admin);\n        SBCWrapperProxy(payable(wrapperProxyAddr)).setAdmin(admin);\n    }\n}\n"
    },
    "src/gnosis/test/UnsafeToken.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"../utils/PausableEIP1967Admin.sol\";\n\n/**\n * @title Unsafe ERC20 that allows admin to mint or steal tokens\n */\ncontract UnsafeToken is ERC20Pausable, PausableEIP1967Admin {\n    constructor() ERC20(\"\", \"\") {}\n\n    /**\n     * @dev Mints new tokens.\n     * @param _to tokens receiver.\n     * @param _amount amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external onlyAdmin {\n        _mint(_to, _amount);\n    }\n\n    /**\n     * UNSAFE: Transfer from funds from any address. Used for testing insolvency scenarios\n     * To transfer all just set _amount to a very high value\n     */\n    function stealFrom(address _from, uint256 _amount) external onlyAdmin {\n        uint256 fromBalance = balanceOf(_from);\n        _amount = _amount <= fromBalance ? _amount : fromBalance;\n        _transfer(_from, msg.sender, _amount);\n    }\n}\n"
    },
    "src/gnosis/utils/Claimable.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Claimable\n * @dev Implementation of the claiming utils that can be useful for withdrawing accidentally sent tokens.\n */\ncontract Claimable {\n    /**\n     * @dev Withdraws the erc20 tokens or native coins from this contract.\n     * @param _token address of the claimed token or address(0) for native coins.\n     * @param _to address of the tokens/coins receiver.\n     */\n    function _claimValues(address _token, address _to) internal {\n        if (_token == address(0)) {\n            _claimNativeCoins(_to);\n        } else {\n            _claimERC20Tokens(_token, _to);\n        }\n    }\n\n    /**\n     * @dev Internal function for withdrawing all native coins from the contract.\n     * @param _to address of the coins receiver.\n     */\n    function _claimNativeCoins(address _to) internal {\n        uint256 balance = address(this).balance;\n        payable(_to).transfer(balance);\n    }\n\n    /**\n     * @dev Internal function for withdrawing all tokens of some particular ERC20 contract from this contract.\n     * @param _token address of the claimed ERC20 token.\n     * @param _to address of the tokens receiver.\n     */\n    function _claimERC20Tokens(address _token, address _to) internal {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).transfer(_to, balance);\n    }\n}\n"
    },
    "src/gnosis/utils/EIP1967Admin.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\n/**\n * @title EIP1967Admin\n * @dev Upgradeable proxy pattern implementation according to minimalistic EIP1967.\n */\ncontract EIP1967Admin {\n    // EIP 1967\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n    uint256 internal constant EIP1967_ADMIN_STORAGE =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin());\n        _;\n    }\n\n    function _admin() internal view returns (address res) {\n        assembly {\n            res := sload(EIP1967_ADMIN_STORAGE)\n        }\n    }\n}\n"
    },
    "src/gnosis/utils/EIP1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"./EIP1967Admin.sol\";\n\n/**\n * @title EIP1967Proxy\n * @dev Upgradeable proxy pattern implementation according to minimalistic EIP1967.\n */\ncontract EIP1967Proxy is EIP1967Admin {\n    // EIP 1967\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n    uint256 internal constant EIP1967_IMPLEMENTATION_STORAGE =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    function admin() public view returns (address) {\n        return _admin();\n    }\n\n    function implementation() public view returns (address res) {\n        assembly {\n            res := sload(EIP1967_IMPLEMENTATION_STORAGE)\n        }\n    }\n\n    function setAdmin(address _admin) external onlyAdmin {\n        _setAdmin(_admin);\n    }\n\n    function upgradeTo(address _implementation) external onlyAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n     * This function will return whatever the implementation call returns\n     */\n    fallback() external payable {\n        address impl = implementation();\n        require(impl != address(0));\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for transfer current admin rights to a different account.\n     * @param _admin address of the new administrator.\n     */\n    function _setAdmin(address _admin) internal {\n        address previousAdmin = admin();\n        require(_admin != address(0));\n        require(previousAdmin != _admin);\n        assembly {\n            sstore(EIP1967_ADMIN_STORAGE, _admin)\n        }\n        emit AdminChanged(previousAdmin, _admin);\n    }\n\n    /**\n     * @dev Internal function for setting a new implementation address.\n     * @param _implementation address of the new implementation contract.\n     */\n    function _setImplementation(address _implementation) internal {\n        require(_implementation != address(0));\n        require(implementation() != _implementation);\n        assembly {\n            sstore(EIP1967_IMPLEMENTATION_STORAGE, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n}\n"
    },
    "src/gnosis/utils/PausableEIP1967Admin.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./EIP1967Admin.sol\";\n\n/**\n * @title PausableEIP1967Admin\n * @dev Pausable contract, controlled by the current EIP1967 proxy owner.\n */\ncontract PausableEIP1967Admin is EIP1967Admin, Pausable {\n    function pause() external onlyAdmin {\n        _pause();\n    }\n\n    function unpause() external onlyAdmin {\n        _unpause();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}